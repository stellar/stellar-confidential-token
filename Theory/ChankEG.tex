
\newcommand{\basefactor}{\MathAlgX{baseFcts}}
\newcommand{\FshS}{{\sf Fsh}}

%%%%%%Twisted EG in the exponent
\newcommand{\EgKg}{\MathAlgX{EgGen}}

\newcommand{\EgEnc}{\MathAlgX{EgEnc}}
\newcommand{\EgDec}{\MathAlgX{EgDec}}



\newcommand{\EgKeyGens}{{{\sf EgKG}}}
\newcommand{\rEgKeyGen}{\cR_\EgKeyGens}
\newcommand{\rEgKeyGenDef}
{
	\sset{(E,e))\colon e\cdot G= E}
}


\newcommand{\EgEncs}{{{\sf EgEnc}}}
\newcommand{\rEgEnc}{\cR_\EgEncs}
\newcommand{\rEgEncDef}
{
	\sset{((H,E,\tA),(a,r))\colon \EgEnc_{(H,E)}(a;r)= \tA}
}

\newcommand{\wEgEnc}{\MathAlgX{\widehat{EgEnc}}}
\newcommand{\wEgDec}{\MathAlgX{\widehat{EgDec}}}

\newcommand{\EgConsSkS}{{{\sf EgCons}}}
\newcommand{\rEgConsSk}{\cR_\EgConsSkS}
\newcommand{\rEgConsSkDef}
{
	\sset{((H,E,\tA,a),e)\colon e\cdot E  \sland \wEgDec_e(\tA) = a\cdot G}
}


\newcommand{\rtFshs}{{{\sf EgFsh}}}
\newcommand{\rtFsh}{\cR_\rtFshs}
\newcommand{\rtFshDef}
{
	\sset{((\pk,\oA,b),(\oa,\orr))\colon \forall i\in (\ell)\colon  \EgEnc_\pk(\oa_i;\orr_i)= \oA_i  
		\sland \oa_i \in (b)}
}


\newcommand{\rEgEqs}{{{\sf EgEq}}}
\newcommand{\rEgEq}{\cR_\rEgEqs}

\newcommand{\rEgEqDef}
{
	\sset{(((H,E_0,E_1,\tA_0,\tA_1),(a,r_0,r_1))\colon \forall i\in \zo \colon \; \EgEnc_{(H,E_i)}(a;r_i)= \tA_i}
}



\newcommand{\EgEqSkS}{{{\sf EgEqSk}}}
\newcommand{\rEgEqSk}{\cR_\EgEqSkS}

\newcommand{\rEgEqSkDef}
{
	\sset{((H,E,\tA_0,\tA_1),e)\colon   e\cdot   G = E \sland \wEgDec_e(\oA_0)= \wEgDec_e(\oA_1)}
}

\newcommand{\EgEqPedS}{{{\sf EgEqPed}}}
\newcommand{\rEgEqPed}{\cR_\EgEqPedS}

\newcommand{\rEgEqPedDef}
{
	\sset{((H,E,\tA,A),(a,r,r'))\colon    \EgEnc_{H,E}(a;r)= \tA \sland \Ped_H(a;r') = A}
}




\newcommand{\EgRps}{{{\sf EgRp}}}
\newcommand{\rEgRp}{\cR_\EgRps}
\newcommand{\rEgRpDef}
{
	\sset{((H,E,\tA,b),(a,r))\colon \EgEnc_{(H,E)}(a;r)= \tA \sland a\in (b)}
}



%%%%Pedersen
\newcommand{\Ped}{\MathAlgX{Ped}}



\newcommand{\PedEncs}{{\sf PedEnc}}
\newcommand{\rPedEnc}{\cR_\PedEncs}

\newcommand{\rPedEncDef}
{
	\sset{((H,A),(a,r))\colon \Ped_H(a;r)= A}
}





\section{The Chunk-ElGamal  Encryption Scheme}\label{sec:ChanksEg}
In this section, we define the  (almost) additive homomorphic encryption scheme based on ElGamal multiplicative  homomorphic encryption scheme.  \Inote{give citations}
The idea is to bootstrap the so-called   \textit{ElGamal in-the exponent}   additive homomorphic encryption/commitment  scheme,\footnote{It is called ElGamal ``in-the-exponent'' due to typical multiplicative group notation. Here use additive group notation, but keep the name for historical reason.}  which in turn is based on the  ElGamal multiplicative  homomorphic encryption scheme, that lacks efficient decryption algorithm, by splitting the plain text into small ``chunks''. That  is, we present a message $a\in Z_t$ as $\sum_{i \in (t/c)}   2^{i c} \cdot a_i$, where $c$, the chunk size, is  some inEgEr  dividing $t$, and encrypt each of the $a_i$ using    additive homomorphic EG. To decry $\oA= (A_0,\ldots,A_{t/c})$, one  
\begin{enumerate}
	\item Decrypt   each $A_i$ to get $a_i  \cdot G$.
	\item Use brute force to find $a$.\footnote{One can use    processing to speed-up this part from $c$ group operations to $\sqrt{c}$  operations, or even \Inote{cite} to   $\sqrt[3]{c}$.}
	
	\item Reconstruct $a$.
\end{enumerate}
In \cref{sec:ChanksEg:Eg}, we formally define the  ElGamal in-the-exponent scheme, and a few ZK proofs for the \NP-relations the scheme induces. Actually, we use a ``twisted'' variant of this scheme, that supports somewhat more efficient proofs in our settings.   The chunk ElGamal  scheme is defined in \cref{sec:ChanksEg:EgScheme}, and the related ZK proofs are defined in \cref{sec:ChanksEg:Proofs}. Finally, in \cref{sec:ChanksEg:Adjusting} we explain  how to adjust \cref{prot:ConfidentialTransactions} to work with this almost homomorphic scheme.

\subsection{Twisted ElGamal In-the-Exponent Encryption Scheme}\label{sec:ChanksEg:Eg}
Throughout we fix a cyclic  additive $q$-size group $\cG$ with generator $G$. The  twisted ElGamal in-the-exponent encryption scheme $(\EgKg,\EgEnc,\EgDec)$ is defined below. Note that it  gets  $H\in \cG$ as an  additional parameter. The ciphertext of the encryption scheme are elements of $\cG \times \cG$. We will mark such  ciphertexts   using tilde, and  address  the left-hand side and right-hand side of such  a ciphertext $\tA$,  by $\tA_L$ and  $\tA_R$, respectively. 


\begin{notation}[Pedersen commitment]
Let $\Ped_H(a;r) \eqdef r\cdot H + a \cdot G$.
\end{notation}

\begin{algorithm}[$(\EgKg,\EgEnc,\EgDec)$: Twisted ElGamal in-the-exponent encryption]\label{alg:tEGinExp}~
	
	
	\item[Key generation:] $\EgKg(1^b,H)$ samples $e\getsr \Z_q$, and outputs $(\sk 
	\asn e,\pk \asn (1^b,H,E\asn  e^{-1}\cdot H))$.
	
	\item[Encryption:] $\EgEnc_{(H,E)}(a)$  samples $r\getsr \Z_q$, and outputs  $\tA  = (\tA _L,\tA _R)\asn (r\cdot E, \Ped_H(a;r))$. 
	\item[Decryption:] $\EgDec_{(1^b,H,e)}(\tA)$,   
	\begin{enumerate}
		\item 	Let $M \asn \tA_R - e\cdot \tA_L$.
		
		\item Find (using brute force) $m\in (-b, b) \in \Z_q$ so that $m\cdot G = M$. Abort if no such $m$ exists.
		
		\item Output $m$.
	\end{enumerate}
	
	\item[Addition:] Addition over  $\cG^2$.\footnote{For $\tA,\tB \in \cG^2$: $\tA +\tB \eqdef (\tA_L+\tB_L,\tA_R+\tB_R)$.}
	
	\item[Minus:]  The inverse, \ie minus, in $\cG^2$.
	
\end{algorithm}	
When clear from the context,  will omit the parameters $1^b$ from the public key of the scheme.

Namely, the right hand side if a twisted ElGamal ciphertext is just a  Pedersen  commitment \cite{Pedersen91} (of the same palaintext). This change enable  using proofs that  support  Pedersen commitment on the ciphertext without changing it, but doing that  should be done with care.
\begin{enumerate}
	\item The parameter $H$ should be chosen so that the prover does not know that discrete log of $H$ \wrt $G$. (Otherwise, a proof of the Pedersen part means nothing).
	
	\item When using a proof of  the Pedersen part (which should always be POK, since Pedersen is perfectly hiding), it should \emph{always} be accompanied with a POK of the palaintext for the whole EG encryption (otherwise, the palaintext and randomness  extracted by the  Pedersen POK, might be  inconsistent with  EG publicj key)  
\end{enumerate}

\begin{theorem}[Security  of twisted-ElGamal in-the-exponent]\label{thm:tEGinExp}
	Assuming DDH is hard over $\cG$, then \cref{alg:tEGinExp} is  a perfectly binding,  semantically secure additively homomorphic scheme over $\Z_q$, with the following caveat:  the description only guaranteed to work on encryptions of explain in $(b)$,   for $1^b$ being the parameter  of the key generation algorithm:
\end{theorem}



\subsubsection{Zero-Knowledge Proofs}\label{sec:ChanksEg:Eg:ZK}

In \cref{sec:ChanksEg:EgScheme} we make use of ZK proofs for the following relations regrading the above scheme.   We use the following notation:
\begin{notation}
Let   $\wEgDec_e (\tA) \eqdef \tA_1- e\cdot \tA_0$.  
\end{notation}
Namely, decryption without finding discrete log.  


\begin{description}
	\item[Knowledge of secret key.] ~
	
	
	
	\begin{description}
		\item[Task:] ZKPOK for $\rEgKeyGen = \rEgKeyGenDef$.
		
		\item[Protocol:] The standard Schnorr proof for discrete log \cite{Shoup00b}.
	\end{description}
	
	
	\item[Knowledge of plain text.] ~
	
	\begin{description}
		\item[Task:] ZKPOK for  $\rEgEnc=\rEgEncDef$.
		
		\item[Protocol:]   \cite[Protocol A.2]{HaitnerLNR23}.
		
	%	$$\rPedEnc = \rPedEncDef $$
	%	Namely, the proof is only applied to  $\tA_1$, \ie the right hand side of the ciphertext. 
		
	\end{description}
	
	
		\item[Conssitency  with plaintext using secret key.] ~
	
	\begin{description}
		\item[Task:] ZKPOK for  $\rEgConsSk=\rEgConsSkDef$.
		
		\item[Protocol:]   
		
		\Pc proves that $\tB \asn (\tA_L, \tA_R - a \cdot G)$ is an encryption of $0$ under $E$. Specifically, that it knows $e$ so that  $e\cdot \tB_R  = \tB_L$. This is just the standard Schnorr proof for discrete log.
		
		%	$$\rPedEnc = \rPedEncDef $$
		%	Namely, the proof is only applied to  $\tA_1$, \ie the right hand side of the ciphertext. 
		
	\end{description}
	
	
	
	\item[Equality.] ~

	
	
	\begin{description}
		\item[Task:] ZKP for  $\rEgEq =\rEgEqDef$.
		
		
		Namely, the relation  is of  ciphertexts that encrypt the  same value under the different  public key, where the witness  is the plaintext and the two randomness used by the encryption algorithm.
		
		\item[Protocol:] The Sigma protocol for this relation concatenates, with the same challenge $t$, two proofs of $\rEgEnc$. 

\item[Protocol for the case $E_0=E_1$:] For this case, the proof is somewhat simpler. \Pc proves that $\tB \asn \tA_1 - \tA_0$ is an encryption of $0$ under $E$. Specifically, that it knows $r$ (\ie $r\asn r_1 -r_0$) so that  $\tB  = r\cdot (E,H)$. The Sigma protocol for this relation concatenates, with the same challenge $t$, two discrete log proofs. (Thus, prover only sends two group elements, vs four above.)        		
\end{description}


\item[Equality using secret key.]~




\begin{description}
	\item[Task:] ZKP for  $\rEgEqSk =\rEgEqSkDef$. Namely, the relation  is of  ciphertexts that encrypt the  same value under the same public key. The witness is the secret key.
	
	\item[Protocol:] \Pc proves that $\tB \asn \tA_1 - \tA_0$ is an encryption of $0$ under $E$. Specifically, that it knows $e$ so that  $e\cdot \tB_R  = \tB_L$. This is just the standard Schnorr proof for discrete log.
	
\end{description}


\item[Equality with Pedersen commitment.]~

\begin{description}
	\item[Task:] ZKP for  $\rEgEqPed =\rEgEqPedDef$.
	
	\item[Protocol:]  The Sigma protocol for this relation concatenates, with the same challenge $t$, a  proof of $\rEgEnc$ and a POK for  Pedersen  commitment  \cite[Protocol A.1]{HaitnerLNR23}..  
\end{description}	


	\item[In range.] ~
	\begin{description}
		\item[Task:] ZKP for $\rEgRp =\rEgRpDef$.
		
		\item[Protocol:]  The proof consists of two parts:
		\begin{enumerate}
			\item  \textit{Bullet proofs} \cite{SP:BBBPWM18}  (which is  ZKPOK) on $\tA_1$ (\ie right hand side of $\tA$).   
			
			
			
			\item   $\rEgEnc$ ZKPOK  for the whole $\tA$.
			
			
		\end{enumerate}


\item[Efficiency.]
	The saving in the above protocol comparing to using  non-twisted EG, is in  two  group elements in the proof size;  the prover does not have to provide a new Pedersen commitment (one group element)  for the plain text and prove it is consistent with the EG encryption (three group elements). Yet, he still has to preform an EG POK proof (two group elements).
		
	\end{description}

\end{description}





	
\subsection{The Chunk-ElGamal  Scheme}\label{sec:ChanksEg:EgScheme}
In the following we fix $t,c\in \N$ with $t\le q$ and $\ell \asn t/c \in \N$. The chunk ElGamal encryption scheme  is defined as follows:



\begin{definition}[Base factorization]\label{def:basefactor}
For $a\in \Z_q$ let $a_0,\ldots,a_{\ell-1}$ so that $a =  \sum_{i \in (\ell)}    2^{i c} \cdot a_i$.
\end{definition}


\begin{algorithm}[$(\KeyGen,\Enc,\Dec)$: Chunk ElGamal adaptively homomorphic encryption]\label{alg:ChunkEGa}~
	
	\item[Key generation:] $\KeyGen(1^b,H)$: act as $\EgKg(1^b,H)$.
	
	\item[Encryiption:] $\Enc_\pk(a)$
	
	\begin{enumerate}
		\item Compute $(a_0,\ldots,a_{\ell-1}) \asn \basefactor(a)$.
		
		\item For each $i\in (\ell)$: let $\tA_i \getsr \EgEnc_\pk(a_i)$.
		
		\item Output $\oA \asn (\tA_0,\ldots, \tA_{\ell-1})$.
		
	\end{enumerate}
	 
	\item[Decription:] $\Dec_\sk(\oM,b)$   
	\begin{enumerate}
		\item 	 For each $i\in (\ell)$: let $m_i \getsr \EgDec_\sk(\oM_i,b)$.
		
		\item Let  $m \asn \sum_{i \in (\ell)}   2^{i c} \cdot  m_i $.
		
		\item Output $m$.
	\end{enumerate}
	
	\item[Addition:] Vector addition.\footnote{For $\oA,\oB \in (\cG^2)^\ell$, $\oA +\oB \eqdef (\tA_0+\tB_0,\ldots,\tA_{\ell-1}+\tB_{\ell-1})$.}
	
	\item[Minus:]  Vector negation.
	                     
	
\end{algorithm}


\begin{theorem}[Security  of Chunk ElGamal]\label{thm:ChunkEG}
	Assuming \DDH is hard over $\cG$, then \cref{alg:ChunkEGa} is  a perfectly binding,  semantically secure additively homophobic scheme over $\Z_q$, with the following caveat work on encryptions of plaintext  $a$ so that $\basefactor(a)\in (-b,b)^\ell$ ($1^b$ being the input of the key generation algorithm).
\end{theorem}


\subsubsection{Zero-Knowledge  Proofs }\label{sec:ChanksEg:Proofs}
In this section, we define the ZK and POK proofs used in  \cref{sec:MainProtocol}.
In the following, we omit the parameter $b$ from the input list of  \Dec.  We will address its value in \cref{sec:ChanksEg:Adjusting}.


\begin{description}
	\item[Knowledge of secret key.] ~
	
	\begin{description}
		\item[Task:] ZKPOK for $\rKeyGen=\rKeyGenDef$.
		
		\item[Protocol:] Same as \piZKPOK{\rEgKeyGen}. 
		
	\end{description}
	
	
	\item[Knowledge of plain text.] ~
	
	

	\begin{description}
		\item[Task:] ZKPOK for $\rEnc=\rEncDef$.
		
		\item[Protocol:]~
		
		\begin{description}
			\item[\Pc:] On  input  $((\pk,\oA),(\oa,\orr)$.
			\begin{enumerate}
				\item For each $i\in (\ell)$: let  $\pi_i \asn \piZKPOK{\rEgEnc}((\pk,\oA_i),(\oa_i,\orr_i))$. 
				
				\item Output $\pi \asn (\pi_0,\ldots, \pi_{\ell-1})$.
				
			\end{enumerate}
			
			
			\item[\Vc:] On  input  $((\pk,\oA),\pi = (\pi_0,\ldots, \pi_{\ell-1}))$: Accept iff  $\vZK{\rEgEnc}((\pk,\tA_i), \pi_i)$ for all $i\in (\ell)$.
			
		\end{description} 
		
		
	\end{description}
	
	\begin{proof}
		Immediate.
	\end{proof}
	
\item[Equality.]~ 

\begin{description}
	\item[Task:] ZKP for $\rEq =\rEqDef$.
	
	\item[Protocol:]~
	
	\begin{description}
		
	\item[\Pc:]  On input $((\pk_0,\pk_1,\oA_0,\oA_1),(e_0,\orr_1))$: 
	

	\begin{enumerate}
		
		\item Let  $a \asn  \sum_{i\in (\ell)}    2^c \cdot \oa_i$. 
		
		\item For both $j\in \zo$:  $\tA_j \asn  \sum_i  2^c \cdot (\oA_j)_i$. 
		
		  
		\item    $r_1 \asn  \sum_{i\in (\ell)}  2^c \cdot (\orr_1)_i$. 
			
		 
		\item Output $\pi \asn \pZK{\rEgEq}((\pk,\tA_0,\tA_1), (e_0,r_1))$.
				 
	\end{enumerate}
	
	\item[\Vc:] On input $((\pk_0,\pk_1,\oA_0,\oA_1),\pi)$: 
	
	\begin{enumerate}
		\item Generate $\tA_0$ and  $\tA_1$ as done by \Pc.
		
	\item Apply $\vZK{\rEgEq}((\pk,\tA_0,\tA_1), \pi)$.
	
	\end{enumerate}
\end{description}
	\end{description}
		

\begin{proof}
	\Inote{TODO}
\end{proof}
  



\item[In range.]~  

\begin{description}
	\item[Task:] ZK for $\rRp =\rRpDef$.
	
	\item[Protocol:]~
	
	\begin{description}
	\item[\Pc:] On input $((\pk,\oA,b),(\oa,\orr))$:
	
	\begin{enumerate}
			\item   $a \asn  \sum_{i\in (\ell)}   2^c \cdot \oa_i$. 
		\item    $\tA \asn  \sum_{i\in (\ell)}    2^c \cdot \oA_i$. 
		\item    $r \asn  \sum_{i\in (\ell)}  2^c \cdot \orr_i$. 
        
        \item  Output $\pi \asn \pZK{\rEgRp}((\pk,\tA,b), (a,r))$.
        
	\end{enumerate}
	
	
\item[\Vc:] On input $((\pk,\oA,b),\pi)$:
	
	\begin{enumerate}
		\item   Generate $\tA$ as by \Pc.
		\item  Output $\vZK{\rEgRp}((\pk,\tA,b), \pi)$.
		
	\end{enumerate}
	
\end{description}
\end{description}

		\begin{proof}
			\Inote{TODO}
		\end{proof}
\item[In-range proof using sceret key.]~  

\begin{description}
	\item[Task:] POK for $\rRpSk =\rRpSkDef$.
	
	
	\item[Protocol:] Similar line to the protocol for $\rRp$, but  the prover  decrypt $\tA$, encrypt the plaintext sing  fresh randomness, and continues as above.
	
	
	\begin{description}
		\item[\Pc:] On input $((E,\oA,b),e)$:
		
		\begin{enumerate}
		
			\item    $\tA \asn  \sum_{i\in (\ell)}    2^c \cdot \oA_i$. 
			
			\item   $a \asn  \Dec_e(\tA)$.
			
			\item   $\tA' \asn \Enc_E(a;r)$ for $r\getsr \Z_q$.
			
				
			
			\item  Let  $\pi^\EgEqSkS \getsr \pZK{\rEgEqSk}((E,\tA,\tA'
			), e)$.
				
			\item  Let  $\pi^\EgRps \getsr \pZK{\rEgRp}((E,\tA',b), (a,r))$.
			
			\item Send $(\pi^\EgEqSkS,\pi^\EgRps)$ to \Vc.
		\end{enumerate}
		
		
		\item[\Vc:] On input $((\pk,\tA',b),\pi^\EgEqSkS,\pi^\EgRps)$:
		
		\begin{enumerate}
			\item   Generate $\tA$ as by \Pc.
			\item  Call $\pZK{\rEgEqSk}((E,\tA,\tA'
			), \pi^\EgEqSkS)$ and  $\pZK{\rEgRp}((E,\tA',b), (a,r))$.
			
		\end{enumerate}
		
	\end{description}

	
\end{description}
	
\item[Freshness.]  ~
Proving that each of the entries of the  ciphertext are small. 

\begin{description}
	\item[Task:] ZKP for $\rtFsh =\rtFshDef$.

\item[Protocol:]~

\begin{description}	
	\item[\Pc:] On  input  $((\pk,\oA,b),(\oa,\orr)$:
	
	\begin{enumerate}
		\item For each $i\in (\ell)$: $\pi_i \asn \pZK{\rEgRp}((\pk,\tA_i,b), (\oa_i,\orr_i))$.
		\item Output $\pi \asn (\pi_0,\ldots, \pi_{\ell-1})$.
	\end{enumerate}
	 
	 
	 	\item[\Vc:] On  input  $((\pk,\oA,b), \pi= (\pi_0,\ldots, \pi_{\ell-1}))$: Accept iff  $\vZK{\rEgRp}((\pk,\tA_i,b), \pi_i)$ for all $i\in (\ell)$.
	 
	 
\end{description}

\end{description}

\begin{proof}
	\Inote{TODO}
\end{proof}
\end{description}


\subsection{Adjusting  \cref{prot:ConfidentialTransactions}}\label{sec:ChanksEg:Adjusting}
Since the decryption procedure of of chunk-ElGamal  encryption scheme only guarantees to work on certain type of ciphertexts, see \cref{thm:ChunkEG} and take a group element, \ie $H$, as an additional parameter,  instantiating \cref{prot:ConfidentialTransactions} with this scheme  requires some adjustments.

\begin{enumerate}
	
	\item[Init:] 
	\begin{enumerate}
		\item The parties  call an ideal functionality that returns $H \getsr \cG$.\footnotetext{Can be implemented using a proper protocol, ot sampled by a trusted  setup.}
		  
		\item 	Each $\Uc_i$ sets the parameters of the encryption key generation algorithm to $(1^b,H)$, for  $b \asn 2^{c}\cdot \pcount$.

	\end{enumerate}
 
	\item[Transfer.]  The sender also provide proofs that $X_d$ is fresh (\ie using \pZK{\rtFsh} with parameter $b\asn 2^c$).
	
	
	\item[Rollover:] The rollover over operation should be updated to allow the account holder to ``normalize''  its active balance: to make it fresh. Specifically
	
	\begin{enumerate}
		\item $\Uc_i$:
		
		\begin{enumerate}
			\item Decrypt $\oP_i$ and $\oB_i$ to get value $(p_i,r_i)$ and $(b_i,w_i)$ respectively.
			
			
			\item Generate a fresh  encryption $\oB_i'$ of $(p_i +b_i )$ and $\oP_i'$ of $0$.
			
			\item Generate a proof $\pi_\Eqs$ (\ie using \pZK{\rEq})   that $\oP_i+\oB_i = \oP_i'+ \oB_i'$.
			
			
		%	\item  Generate proofs $\pi^P_\Fshs$ and $\pi^B_\Fshs$ (\ie using \pZK{\rtFsh})   that $\oP_i'$ and $\oB_i'$ are fresh.
			
			\item Send $(\oP_i',\oB_i',\pi_\Eqs,\pi^P_\FshS,\pi^B_\FshS)$ to \Cc.
		%
			\item Send $(\oP_i',\oB_i',\pi_\Eqs)$ to \Cc.
		
		
		\end{enumerate}
		
		\item $\Cc$:
			\begin{enumerate}
			%	\item Verify $\pi_\Eqs,\pi^P_\Fshs$ and $\pi^B_\Fshs$.
				
					\item Verify $\pi_\Eqs$.
				
				\item Set $\oP_i  \asn \oP_i'$  and $\oB_i  \asn \oB_i'$.
				
				\item Continue as in the original protocol.
			\end{enumerate}
		
	\end{enumerate}
\end{enumerate}


\subsection{Efficient Improvements}\label{sec:ChanksEg:EfficientImp}

\begin{enumerate}
	\item The bullet proofs used  in the In range and the freshness proofs can be batched. 
	
	\item The Schnorr proofs can be batched. In particular, the one performed in the different In-range proofs.  
\end{enumerate}



\newcommand{\tdKg}{\MathAlgX{TdGen}}

\newcommand{\tdEnc}{\MathAlgX{TdEnc}}
\newcommand{\tdDec}{\MathAlgX{TdDec}}

\subsection{The TDH2 \Inote{?} Threshold Encryption Scheme }\label{sec:ChanksEg:TDH}	
\Inote{Work in progress}

In this section, we present   the TDH2 threshold  encryption scheme. 
It will be used for the  auditing capability  of the confidential translation protocol.  

In the following, fix the number of public keys to $n<q$ and the threshold $t \le n$, and the plain text domain $\zo^\ell$. The threshold scheme  $(\tdKg,\tdEnc,\tdDec)$ is defined as follows:


\begin{notation}[Lagrange basis functions]
 	For $\cS \subseteq [n]$ and $i\in \cS$, let $\lambda_i^\cS \eqdef \prod_{j \in \cS \setminus \set{i}} \frac{-i}{j-i}$.
\end{notation}

\begin{algorithm}[$(\tdKg,\tdEnc,\tdDec)$: The TDH2  Encryption Scheme]\label{alg:TDH2}~
	
	\item[Oracles:] $h\colon \cG \mapsto \zo^\ell$. \Inote{define $\cD$}
	\item[Key generation:] $\tdKg()$:
	\begin{enumerate}
		\item Sample  a uniform degree $t-1$ polynomial  $p$. 
		
		\item For each $i\in (n+1)$: Let $x_i \asn p(i)$.
		
		 
		
		 \item Output public key $E \asn x_0 \cdot G$, and secret keys $x_1,\ldots,x_n$.
	\end{enumerate}
	

	
	\item[Encryption:]  $\tdEnc_E(m;r)$ sample $r\getsr \Z_q$ and output $(r\cdot G, h(r\cdot E)  \xor m)$.\footnote{I.e., this is just the ElGamal (not in the exponent) encryption algorithm.} 
	
	
	\item[Decryption:] Protocol $\tdDec(U,c)$ between parties  $\set{\Pc_i}_{i\in \cS}$ for some $t$-size $\cS \subseteq [n]$, holding secret keys $\set{x_i}$, and combiner \Cc.
	
	\begin{enumerate}
		\item Party $\Pc_i$, for all $i\in \cS$:  Send   $U_i \asn x_i \cdot U$ to \Cc.
		
		\item  \Cc: Output $m \asn c \xor h(\sum_{i\in [t]}   \lambda_i^\cS \cdot U_i)$. 
		

	\end{enumerate}
	 
	
\end{algorithm}	

\subsubsection{Zero-knowledge Proofs}

\remove{

\newcommand{\tsEgKg}{\MathAlgX{TshEgGen}}

\newcommand{\tsEgEnc}{\MathAlgX{TshEgEnc}}
\newcommand{\tsEgDec}{\MathAlgX{TshEgDec}}

\subsection{Threshold  ElGamal}\label{sec:ChanksEg:TshEg}	
In this section, we present a simple   threshold variant of the twisted-ElGamal-in-the-exponent  scheme described in \cref{sec:ChanksEg:Eg}. The chunk version of this scheme, described below, will be used for the  auditing capability  of the confidential translation protocol. The threshold scheme  $(\tsEgKg,\tsEgEnc,\tsEgDec)$ is based on Feldman verifiable secret sharing defined as follows:



\begin{algorithm}[$(\tsEgKg,\tsEgEnc,\tsEgDec)$: Threshold, twisted ElGamal in-the-exponent encryption]\label{alg:tsEGinExp}~
	
	
	\item[Key generation:] $\tsEgKg(1^b,H)$ each party generates its public key as in \EgKg.
	
	\item[Encryption:] $\tsEgEnc_{(t,\pk_1= (H,E_1),\ldots,\pk_n)}(a)$:
	
	\begin{enumerate}
		\item Sample a uniform degree $t-1$ polynomial  $p$ with $p(0)= a$. 
		
		\item  For $i \in [n]$: Let $\tA_i \asn \EgEnc_{\pk_i}(p(i))$.
		
		
		\item Output $(t,\pk_1,\ldots,\pk_n,\tA_1,\ldots,\tA_n)$
		
	\end{enumerate}
	
	
	\item[Decryption:] Protocol $\tsEgDec(t,\pk_1,\ldots,\pk_n,\tA_1,\ldots,\tA_n)$ between parties  $\Pc_{u_1},\ldots,\Pc_{u_t}$ holding secret keys $\sk_{u_i}, \ldots,\sk_{u_t}$.
	
	\begin{enumerate}
		\item 	Each $\Pc_{u_i}$:
		
		\begin{enumerate}
			\item Let  $a_i \asn \EgDec_{\sk_{u_i}} (\tA_{u_i})$.
			
			\item  Send $a_i$ to other parties.\footnote{Depending on the context, we might ask $\Pc_{u_i}$ to prove that $a_i$ is  the correct decryption of $\tA_{u_i}$. This can be  done using   \piZKPOK{\rEgConsSk}.}
		\end{enumerate} 
		
		\item Each party uses $\set{a_i}_{i\in [t]}$ to reconstruct 	the degree $t-1$ polynomial $p$ and  outputs $p(0)$.
		
		
	\end{enumerate}
	
	\item[Addition:] For $u = (t,\pk_1,\ldots,\pk_n)$, 
	
	$(u,\tB_1,\ldots,\tB_n) + (u,\tB_1',\ldots,\tB_n') \eqdef (u,\tB_1+\tB_1',\ldots,\tB_n)$.
	
	
	\item[Minus:]  For $u = (t,\pk_1,\ldots,\pk_n)$,  $(u,\tB_1,\ldots,\tB_n) \eqdef (u,-\tB_1,\ldots,-\tB_n) $.
	
\end{algorithm}	
When clear from the context,  will omit the parameters $1^b$ from the public key of the scheme, and omit the  $(t,\pk_1,\ldots,\pk_n)$ part  from the ciphertexts.


\newcommand{\TsEgEncs}{{{\sf tEgEnc}}}
\newcommand{\rTsEgEnc}{\cR_\TsEgEncs}
\newcommand{\rTsEgEncDef}
{
	\sset{((t,\pk_1,\ldots,\pk_n,\tA_1,\ldots,\tA_n),(a,r))\colon \tsEgEnc_{(t,\pk_1,\ldots,\pk_n)}(a;r)= (\tA_1,\ldots,\tA_n)}
}



\subsubsection{Zero-Knowledge Proofs}\label{sec:ChanksEg:tsEGinExp:ZK}


\begin{description}




\item[Knowledge of plain text.] ~

\begin{description}
	\item[Task:] ZKPOK for  $\rTsEgEnc=\rTsEgEncDef$.
	
	\item[\Pc:]   

	\begin{enumerate}
	\item Let $p$  and denote the degree $t-1$ polynomial  sampled by \tsEgEnc and let $\sset{c_i}$ denote its coefficients.   Let $\sset{r_i^{\tA}}$ denote the  randomness used to sample $\set{\tA_1}$  (all induced by the  witness randomness $r$).
	
	
	\item For $j\in (t)$: 
	
	\begin{enumerate}
		\item Sample  $r^C_j\getsr \Z_q$.
		
		\item Let $C_j \asn \Ped_{H}(c_j;r^C_j)$.
		
	\end{enumerate}
	
	\item  For $i \in [n]$: 
	
	
	\begin{enumerate}
		\item  Let $A_i \asn  \sum_{j\in (t)} C_j  \cdot i^j$ and let $r_i^A  \sum_{j\in (t)} r^C_j  \cdot i^j$ . \comment{Pedersen commitment to $p(i)$}
		
	
		\item Let $\pi_i \getsr \pZKPOK{\rEgEqPed}((E_i,H,\tA_i,A_i),(r_i^{\tA},r_i^A))$.
	\end{enumerate}
	
	\item Output $\sset{C_j}_{j\in (t)},\sset{\pi_i}_{i\in [n]}$
\end{enumerate}


\item[\Vc:]   ~

\begin{enumerate}
	
	\item Generate   $\set{A_i}$ as done by \Pc.
	
	\item For each $i$: call $\vZKPOK{\rEgEqPed}((E_i,H,\tA_i,A_i),\pi_i)$.
\end{enumerate}
\end{description}
\end{description}

\subsubsection{Threshold   Chunk ElGammal}
To chunk ElGammal  variant of the threshold scheme is straightforward: the encryption algorithm simply encrypt the $p(i)$'s using the  chunk ElGammal scheme (described by \cref{alg:ChunkEGa}), and the decryption protocol uses the relevant decryption algorithm.  The relevant ZK proofs are adapted a accordingly

\begin{enumerate}
	
	\item For proving consistency of the plain text, as possibly done in the decryption  phase by each of the decryptors, the  prover first converts $\oA_i$   to $\tA_i$, and continues like in the original proof.
	 
	\item In the ZKPOK for  $\rTsEgEnc$, the prover
	\begin{enumerate}
		\item Proves freshness of each of the, now,   $\oA_i$'s.
		
		\item  	Converts the  $\sset{\oA_i}$ into $\sset{\tA_i}$, and continues like in the original protocol.
		
	\end{enumerate}

    The verifier 
    \begin{enumerate}
    	\item Verifies the freshness proofs of the   $\oA_i$'s.
    	
    	\item  	Converts the  $\sset{\oA_i}$ into $\sset{\tA_i}$, and continues like in the original protocol.
    	
    \end{enumerate}
    
	
\end{enumerate} 
}

